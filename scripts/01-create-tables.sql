-- Enable Row Level Security
-- IMPORTANT: Replace 'your-jwt-secret' with a strong, random string (e.g., generated by `openssl rand -base64 32`)
ALTER DATABASE postgres SET "app.jwt_secret" TO 'your-jwt-secret';

-- Create custom types
CREATE TYPE item_condition AS ENUM ('new', 'like_new', 'good', 'fair', 'poor');
CREATE TYPE item_status AS ENUM ('pending', 'approved', 'rejected', 'swapped');
CREATE TYPE swap_status AS ENUM ('pending', 'accepted', 'rejected', 'completed');
CREATE TYPE user_role AS ENUM ('user', 'admin');

-- Users table (extends Supabase auth.users)
CREATE TABLE IF NOT EXISTS public.users (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  avatar_url TEXT,
  points INTEGER DEFAULT 100,
  role user_role DEFAULT 'user',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Items table
CREATE TABLE IF NOT EXISTS public.items (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL,
  type TEXT NOT NULL,
  size TEXT NOT NULL,
  condition item_condition NOT NULL,
  tags TEXT[],
  images TEXT[],
  points_value INTEGER DEFAULT 10,
  status item_status DEFAULT 'pending',
  is_available BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Swaps table
CREATE TABLE IF NOT EXISTS public.swaps (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  requester_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  owner_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  item_id UUID REFERENCES public.items(id) ON DELETE CASCADE NOT NULL,
  offered_item_id UUID REFERENCES public.items(id) ON DELETE CASCADE,
  points_offered INTEGER DEFAULT 0,
  status swap_status DEFAULT 'pending',
  message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Points transactions table
CREATE TABLE IF NOT EXISTS public.points_transactions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  amount INTEGER NOT NULL,
  type TEXT NOT NULL, -- 'earned', 'spent', 'bonus'
  description TEXT,
  related_swap_id UUID REFERENCES public.swaps(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable Row Level Security
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.swaps ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.points_transactions ENABLE ROW LEVEL SECURITY;

-- Helper function to check if the current user is an admin
-- This function runs with SECURITY DEFINER privileges, allowing it to bypass RLS on public.users for this check
CREATE OR REPLACE FUNCTION public.is_admin_user()
RETURNS BOOLEAN AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.users
    WHERE id = auth.uid() AND role = 'admin'
  );
$$ LANGUAGE sql STABLE SECURITY DEFINER;

-- RLS Policies for users
-- Policy 1: Users can view their own profile
DROP POLICY IF EXISTS "Users can view their own profile" ON public.users;
CREATE POLICY "Users can view their own profile" ON public.users
  FOR SELECT USING (auth.uid() = id);

-- Policy 2: Admins can view all users (using the new helper function)
DROP POLICY IF EXISTS "Admins can view all users" ON public.users;
CREATE POLICY "Admins can view all users" ON public.users
  FOR SELECT USING (public.is_admin_user());

-- Policy for users to update their own profile
DROP POLICY IF EXISTS "Users can update their own profile" ON public.users;
CREATE POLICY "Users can update their own profile" ON public.users
  FOR UPDATE USING (auth.uid() = id);

-- Policy for admins to update any user role
DROP POLICY IF EXISTS "Admins can update any user role" ON public.users;
CREATE POLICY "Admins can update any user role" ON public.users
  FOR UPDATE USING (
    public.is_admin_user()
  );

-- Policy for admins to delete any user
DROP POLICY IF EXISTS "Admins can delete any user" ON public.users;
CREATE POLICY "Admins can delete any user" ON public.users
  FOR DELETE USING (
    public.is_admin_user()
  );

-- RLS Policies for items
CREATE POLICY "Anyone can view approved items" ON public.items
  FOR SELECT USING (status = 'approved' OR user_id = auth.uid());

CREATE POLICY "Users can insert their own items" ON public.items
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own items" ON public.items
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Admins can update any item" ON public.items
  FOR UPDATE USING (
    public.is_admin_user()
  );

CREATE POLICY "Admins can delete any item" ON public.items
  FOR DELETE USING (
    public.is_admin_user()
  );

-- RLS Policies for swaps
CREATE POLICY "Users can view their own swaps" ON public.swaps
  FOR SELECT USING (auth.uid() = requester_id OR auth.uid() = owner_id);

CREATE POLICY "Users can create swaps" ON public.swaps
  FOR INSERT WITH CHECK (auth.uid() = requester_id);

CREATE POLICY "Users can update swaps they're involved in" ON public.swaps
  FOR UPDATE USING (auth.uid() = requester_id OR auth.uid() = owner_id);

-- RLS Policies for points transactions
CREATE POLICY "Users can view their own transactions" ON public.points_transactions
  FOR SELECT USING (auth.uid() = user_id);

-- Functions
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, email, full_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to update points
CREATE OR REPLACE FUNCTION public.update_user_points(
  user_id UUID,
  amount INTEGER,
  transaction_type TEXT,
  description TEXT DEFAULT NULL,
  swap_id UUID DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
  -- Update user points
  UPDATE public.users
  SET points = points + amount,
      updated_at = NOW()
  WHERE id = user_id;

  -- Record transaction
  INSERT INTO public.points_transactions (user_id, amount, type, description, related_swap_id)
  VALUES (user_id, amount, transaction_type, description, swap_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
